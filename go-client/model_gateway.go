/*
Sellix Developers API

Sellix public API for developers to access merchant resources

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
)

// Gateway the model 'Gateway'
type Gateway string

// List of gateway
const (
	PAYPAL Gateway = "PAYPAL"
	STRIPE Gateway = "STRIPE"
	SKRILL Gateway = "SKRILL"
	PERFECT_MONEY Gateway = "PERFECT_MONEY"
	CASH_APP Gateway = "CASH_APP"
	BINANCE Gateway = "BINANCE"
	BITCOIN Gateway = "BITCOIN"
	LITECOIN Gateway = "LITECOIN"
	ETHEREUM Gateway = "ETHEREUM"
	BITCOIN_CASH Gateway = "BITCOIN_CASH"
	NANO Gateway = "NANO"
	MONERO Gateway = "MONERO"
	SOLANA Gateway = "SOLANA"
	RIPPLE Gateway = "RIPPLE"
	BINANCE_COIN Gateway = "BINANCE_COIN"
	USDC Gateway = "USDC"
	USDT Gateway = "USDT"
	TRON Gateway = "TRON"
	BITCOIN_LN Gateway = "BITCOIN_LN"
	CONCORDIUM Gateway = "CONCORDIUM"
	POLYGON Gateway = "POLYGON"
	PEPE Gateway = "PEPE"
	DAI Gateway = "DAI"
	WETH Gateway = "WETH"
	APE Gateway = "APE"
	SHIB Gateway = "SHIB"
	USDC_NATIVE Gateway = "USDC_NATIVE"
	DOGECOIN Gateway = "DOGECOIN"
	PYTH Gateway = "PYTH"
	BONK Gateway = "BONK"
	JUP Gateway = "JUP"
	JITO Gateway = "JITO"
	WEN Gateway = "WEN"
	RENDER Gateway = "RENDER"
	MOBILE Gateway = "MOBILE"
	HNT Gateway = "HNT"
)

// All allowed values of Gateway enum
var AllowedGatewayEnumValues = []Gateway{
	"PAYPAL",
	"STRIPE",
	"SKRILL",
	"PERFECT_MONEY",
	"CASH_APP",
	"BINANCE",
	"BITCOIN",
	"LITECOIN",
	"ETHEREUM",
	"BITCOIN_CASH",
	"NANO",
	"MONERO",
	"SOLANA",
	"RIPPLE",
	"BINANCE_COIN",
	"USDC",
	"USDT",
	"TRON",
	"BITCOIN_LN",
	"CONCORDIUM",
	"POLYGON",
	"PEPE",
	"DAI",
	"WETH",
	"APE",
	"SHIB",
	"USDC_NATIVE",
	"DOGECOIN",
	"PYTH",
	"BONK",
	"JUP",
	"JITO",
	"WEN",
	"RENDER",
	"MOBILE",
	"HNT",
}

func (v *Gateway) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := Gateway(value)
	for _, existing := range AllowedGatewayEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid Gateway", value)
}

// NewGatewayFromValue returns a pointer to a valid Gateway
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewGatewayFromValue(v string) (*Gateway, error) {
	ev := Gateway(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for Gateway: valid values are %v", v, AllowedGatewayEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v Gateway) IsValid() bool {
	for _, existing := range AllowedGatewayEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to gateway value
func (v Gateway) Ptr() *Gateway {
	return &v
}

type NullableGateway struct {
	value *Gateway
	isSet bool
}

func (v NullableGateway) Get() *Gateway {
	return v.value
}

func (v *NullableGateway) Set(val *Gateway) {
	v.value = val
	v.isSet = true
}

func (v NullableGateway) IsSet() bool {
	return v.isSet
}

func (v *NullableGateway) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableGateway(val *Gateway) *NullableGateway {
	return &NullableGateway{value: val, isSet: true}
}

func (v NullableGateway) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableGateway) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

